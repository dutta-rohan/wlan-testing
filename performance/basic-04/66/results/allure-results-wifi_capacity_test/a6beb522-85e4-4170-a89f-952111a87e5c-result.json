{"name": "test_client_wpa2_BRIDGE_udp_bidirectional[setup_profiles0]", "status": "broken", "statusDetails": {"message": "scp.SCPException: Error receiving, socket.timeout", "trace": "self = <paramiko.Channel 0 (closed) -> <paramiko.Transport at 0x44e2dd90 (cipher aes128-ctr, 128 bits) (active; 1 open channel(s))>>\nnbytes = 16384\n\n    def recv(self, nbytes):\n        \"\"\"\n        Receive data from the channel.  The return value is a string\n        representing the data received.  The maximum amount of data to be\n        received at once is specified by ``nbytes``.  If a string of\n        length zero is returned, the channel stream has closed.\n    \n        :param int nbytes: maximum number of bytes to read.\n        :return: received data, as a ``str``/``bytes``.\n    \n        :raises socket.timeout:\n            if no data is ready before the timeout set by `settimeout`.\n        \"\"\"\n        try:\n>           out = self.in_buffer.read(nbytes, self.timeout)\n\n/usr/local/lib/python3.8/site-packages/paramiko/channel.py:699: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <paramiko.buffered_pipe.BufferedPipe object at 0x7f6044393490>\nnbytes = 16384, timeout = -0.00012350082397460938\n\n    def read(self, nbytes, timeout=None):\n        \"\"\"\n        Read data from the pipe.  The return value is a string representing\n        the data received.  The maximum amount of data to be received at once\n        is specified by ``nbytes``.  If a string of length zero is returned,\n        the pipe has been closed.\n    \n        The optional ``timeout`` argument can be a nonnegative float expressing\n        seconds, or ``None`` for no timeout.  If a float is given, a\n        `.PipeTimeout` will be raised if the timeout period value has elapsed\n        before any data arrives.\n    \n        :param int nbytes: maximum number of bytes to read\n        :param float timeout:\n            maximum seconds to wait (or ``None``, the default, to wait forever)\n        :return: the read data, as a ``str`` or ``bytes``\n    \n        :raises:\n            `.PipeTimeout` -- if a timeout was specified and no data was ready\n            before that timeout\n        \"\"\"\n        out = bytes()\n        self._lock.acquire()\n        try:\n            if len(self._buffer) == 0:\n                if self._closed:\n                    return out\n                # should we block?\n                if timeout == 0.0:\n                    raise PipeTimeout()\n                # loop here in case we get woken up but a different thread has\n                # grabbed everything in the buffer.\n                while (len(self._buffer) == 0) and not self._closed:\n                    then = time.time()\n                    self._cv.wait(timeout)\n                    if timeout is not None:\n                        timeout -= time.time() - then\n                        if timeout <= 0.0:\n>                           raise PipeTimeout()\nE                           paramiko.buffered_pipe.PipeTimeout\n\n/usr/local/lib/python3.8/site-packages/paramiko/buffered_pipe.py:164: PipeTimeout\n\nDuring handling of the above exception, another exception occurred:\n\nself = <scp.SCPClient object at 0x7f6044e2d4c0>\ncmd = b'0644 104787 udp--1.eth2-01.sta01518-A_1635333922.csv'\n\n    def _recv_file(self, cmd):\n        chan = self.channel\n        parts = cmd.strip().split(b' ', 2)\n    \n        try:\n            mode = int(parts[0], 8)\n            size = int(parts[1])\n            if self._rename:\n                path = self._recv_dir\n                self._rename = False\n            elif os.name == 'nt':\n                name = parts[2].decode('utf-8')\n                assert not os.path.isabs(name)\n                path = os.path.join(asunicode_win(self._recv_dir), name)\n            else:\n                name = parts[2]\n                assert not os.path.isabs(name)\n                path = os.path.join(asbytes(self._recv_dir), name)\n        except:\n            chan.send('\\x01')\n            chan.close()\n            raise SCPException('Bad file format')\n    \n        try:\n            file_hdl = open(path, 'wb')\n        except IOError as e:\n            chan.send(b'\\x01' + str(e).encode('utf-8'))\n            chan.close()\n            raise\n    \n        if self._progress:\n            if size == 0:\n                # avoid divide-by-zero\n                self._progress(path, 1, 1, self.peername)\n            else:\n                self._progress(path, size, 0, self.peername)\n        buff_size = self.buff_size\n        pos = 0\n        chan.send(b'\\x00')\n        try:\n            while pos < size:\n                # we have to make sure we don't read the final byte\n                if size - pos <= buff_size:\n                    buff_size = size - pos\n>               data = chan.recv(buff_size)\n\n/usr/local/lib/python3.8/site-packages/scp.py:471: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <paramiko.Channel 0 (closed) -> <paramiko.Transport at 0x44e2dd90 (cipher aes128-ctr, 128 bits) (active; 1 open channel(s))>>\nnbytes = 16384\n\n    def recv(self, nbytes):\n        \"\"\"\n        Receive data from the channel.  The return value is a string\n        representing the data received.  The maximum amount of data to be\n        received at once is specified by ``nbytes``.  If a string of\n        length zero is returned, the channel stream has closed.\n    \n        :param int nbytes: maximum number of bytes to read.\n        :return: received data, as a ``str``/``bytes``.\n    \n        :raises socket.timeout:\n            if no data is ready before the timeout set by `settimeout`.\n        \"\"\"\n        try:\n            out = self.in_buffer.read(nbytes, self.timeout)\n        except PipeTimeout:\n>           raise socket.timeout()\nE           socket.timeout\n\n/usr/local/lib/python3.8/site-packages/paramiko/channel.py:701: timeout\n\nDuring handling of the above exception, another exception occurred:\n\nself = <tests.e2e.basic.performance_tests.wifi_capacity_test.wpa2_personal.test_bridge_mode.TestWifiCapacityBRIDGEModeDualBand object at 0x7f6044df40d0>\nget_vif_state = ['ssid_wpa2_dual_band', 'ssid_wpa2_dual_band', 'ssid_wpa2_dual_band', 'ssid_wpa2_dual_band']\nlf_tools = <lanforge.lf_tools.ChamberView object at 0x7f6044eeefd0>\nlf_test = <lanforge.lf_tests.RunTest object at 0x7f6044eee250>\nstation_names_twog = ['wlan000'], create_lanforge_chamberview_dut = 'basic-04'\nget_configuration = {'access_point': [{'ip': '10.28.3.100', 'jumphost': True, 'jumphost_tty': '/dev/ttyAP5', 'mode': 'wifi5', ...}], 'cont...hy4'], '2.4G-Station-Name': 'wlan0', '5G-Radio': ['1.1.wiphy5'], '5G-Station-Name': 'wlan0', ...}, 'name': 'lanforge'}}\n\n    @allure.testcase(url=\"https://telecominfraproject.atlassian.net/browse/WIFI-3933\", name=\"WIFI-3933\")\n    @pytest.mark.udp_bidirectional\n    def test_client_wpa2_BRIDGE_udp_bidirectional(self, get_vif_state, lf_tools,\n                                                  lf_test, station_names_twog, create_lanforge_chamberview_dut,\n                                                  get_configuration):\n        \"\"\" Wifi Capacity Test BRIDGE mode\n            pytest -m \"wifi_capacity_test and BRIDGE and wpa2_personal and twog\"\n        \"\"\"\n        lf_tools.reset_scenario()\n        profile_data = setup_params_general_dual_band[\"ssid_modes\"][\"wpa2_personal\"][0]\n        ssid_name = profile_data[\"ssid_name\"]\n        mode = \"BRIDGE\"\n        vlan = 1\n        if ssid_name not in get_vif_state:\n            allure.attach(name=\"retest,vif state ssid not available:\", body=str(get_vif_state))\n            pytest.xfail(\"SSID NOT AVAILABLE IN VIF STATE\")\n        lf_tools.add_stations(band=\"2G\", num_stations=\"max\", dut=lf_tools.dut_name, ssid_name=ssid_name)\n        lf_tools.add_stations(band=\"5G\", num_stations=\"max\", dut=lf_tools.dut_name, ssid_name=ssid_name)\n        # lf_tools.add_stations(band=\"ax\", num_stations=\"max\", dut=lf_tools.dut_name, ssid_name=ssid_name)\n        lf_tools.Chamber_View()\n        influx_tags = [\"udp\", \"bidirectional\", \"2.4G-5G Combined\"]\n>       wct_obj = lf_test.wifi_capacity(instance_name=\"test_client_wpa2_BRIDGE_udp_bi\", mode=mode, vlan_id=vlan,\n                                        download_rate=\"1Gbps\", batch_size=\"1,5,10,20,40,64,128,256\",\n                                        influx_tags=influx_tags,\n                                        upload_rate=\"1Gbps\", protocol=\"UDP-IPv4\", duration=\"60000\")\n\ne2e/basic/performance_tests/wifi_capacity_test/wpa2_personal/test_bridge_mode.py:165: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n../libs/lanforge/lf_tests.py:273: in wifi_capacity\n    wificapacity_obj.run()\n../lanforge/lanforge-scripts/py-scripts/lf_wifi_capacity_test.py:478: in run\n    self.create_and_run_test(self.load_old_cfg, self.test_name, self.instance_name,\n../lanforge/lanforge-scripts/py-json/cv_test_manager.py:394: in create_and_run_test\n    raise e  # Exception(\"Could not find Reports\")\n../lanforge/lanforge-scripts/py-json/cv_test_manager.py:389: in create_and_run_test\n    report.pull_reports(hostname=lf_host, username=lf_user, password=lf_password,\n../lanforge/lanforge-scripts/py-json/cv_test_reports.py:15: in pull_reports\n    scp.get(remote_path=report_location, local_path=report_dir, recursive=True)\n/usr/local/lib/python3.8/site-packages/scp.py:259: in get\n    self._recv_all()\n/usr/local/lib/python3.8/site-packages/scp.py:412: in _recv_all\n    command[code](msg[1:])\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <scp.SCPClient object at 0x7f6044e2d4c0>\ncmd = b'0644 104787 udp--1.eth2-01.sta01518-A_1635333922.csv'\n\n    def _recv_file(self, cmd):\n        chan = self.channel\n        parts = cmd.strip().split(b' ', 2)\n    \n        try:\n            mode = int(parts[0], 8)\n            size = int(parts[1])\n            if self._rename:\n                path = self._recv_dir\n                self._rename = False\n            elif os.name == 'nt':\n                name = parts[2].decode('utf-8')\n                assert not os.path.isabs(name)\n                path = os.path.join(asunicode_win(self._recv_dir), name)\n            else:\n                name = parts[2]\n                assert not os.path.isabs(name)\n                path = os.path.join(asbytes(self._recv_dir), name)\n        except:\n            chan.send('\\x01')\n            chan.close()\n            raise SCPException('Bad file format')\n    \n        try:\n            file_hdl = open(path, 'wb')\n        except IOError as e:\n            chan.send(b'\\x01' + str(e).encode('utf-8'))\n            chan.close()\n            raise\n    \n        if self._progress:\n            if size == 0:\n                # avoid divide-by-zero\n                self._progress(path, 1, 1, self.peername)\n            else:\n                self._progress(path, size, 0, self.peername)\n        buff_size = self.buff_size\n        pos = 0\n        chan.send(b'\\x00')\n        try:\n            while pos < size:\n                # we have to make sure we don't read the final byte\n                if size - pos <= buff_size:\n                    buff_size = size - pos\n                data = chan.recv(buff_size)\n                if not data:\n                    raise SCPException(\"Underlying channel was closed\")\n                file_hdl.write(data)\n                pos = file_hdl.tell()\n                if self._progress:\n                    self._progress(path, size, pos, self.peername)\n            msg = chan.recv(512)\n            if msg and msg[0:1] != b'\\x00':\n                raise SCPException(asunicode(msg[1:]))\n        except SocketTimeout:\n            chan.close()\n>           raise SCPException('Error receiving, socket.timeout')\nE           scp.SCPException: Error receiving, socket.timeout\n\n/usr/local/lib/python3.8/site-packages/scp.py:483: SCPException"}, "description": " Wifi Capacity Test BRIDGE mode\n            pytest -m \"wifi_capacity_test and BRIDGE and wpa2_personal and twog\"\n        ", "parameters": [{"name": "setup_profiles", "value": "{'mode': 'BRIDGE', 'ssid_modes': {'wpa2_personal': [{'ssid_name': 'ssid_wpa2_dual_band', 'appliedRadios': ['5G', '2G'], 'security_key': 'something', 'security': 'psk2'}]}, 'rf': {}, 'radius': False}"}], "start": 1635333846854, "stop": 1635334514057, "uuid": "bdf5fcef-14ab-48d8-a048-cffc5722a4d5", "historyId": "122de191ef90c66f18c660b469d9d8c8", "testCaseId": "fe150834ca03fbfeb4542d99c8fc4835", "fullName": "e2e.basic.performance_tests.wifi_capacity_test.wpa2_personal.test_bridge_mode.TestWifiCapacityBRIDGEModeDualBand#test_client_wpa2_BRIDGE_udp_bidirectional", "labels": [{"name": "feature", "value": "BRIDGE MODE CLIENT CONNECTIVITY"}, {"name": "tag", "value": "udp_bidirectional"}, {"name": "tag", "value": "wpa2_personal"}, {"name": "tag", "value": "bridge"}, {"name": "tag", "value": "fiveg"}, {"name": "tag", "value": "wifi_capacity_test"}, {"name": "tag", "value": "@pytest.mark.usefixtures('setup_profiles')"}, {"name": "tag", "value": "performance"}, {"name": "tag", "value": "dual_band"}, {"name": "tag", "value": "twog"}, {"name": "parentSuite", "value": "e2e.basic.performance_tests.wifi_capacity_test.wpa2_personal"}, {"name": "suite", "value": "test_bridge_mode"}, {"name": "subSuite", "value": "TestWifiCapacityBRIDGEModeDualBand"}, {"name": "host", "value": "perf-1389437946-5qslh"}, {"name": "thread", "value": "8-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "e2e.basic.performance_tests.wifi_capacity_test.wpa2_personal.test_bridge_mode"}], "links": [{"type": "test_case", "url": "https://telecominfraproject.atlassian.net/browse/WIFI-3933", "name": "WIFI-3933"}]}